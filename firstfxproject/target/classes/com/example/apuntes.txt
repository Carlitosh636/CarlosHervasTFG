// un sencillo integerProperty. Esto sería parecido a hacer una variable
        // pública., tiene su getter y setter
        /*
         * IntegerProperty counter = new SimpleIntegerProperty(1);
         * int counterValue = counter.get();
         * System.out.println("Counter:" + counterValue);
         * counter.set(2);
         * counterValue = counter.get();
         * System.out.println("Counter:" + counterValue);
         */

        // esto es una de solo lectura. El Wrapper se puede modificar, pero el Property
        // no, solo leer. Se usan para variables que queremos que sean privadas
        ReadOnlyIntegerWrapper idWrapper = new ReadOnlyIntegerWrapper(100);
        ReadOnlyIntegerProperty id = idWrapper.getReadOnlyProperty();
        System.out.println("idWrapper:" + idWrapper.get());
        System.out.println("id:" + id.get());
        // Change the value
        idWrapper.set(101);
        System.out.println("idWrapper:" + idWrapper.get());
        System.out.println("id:" + id.get());

        Book newBook = new Book();
        newBook.setTitle("The Magnus Archives");
        String title = newBook.getTitle();
        System.out.println(title);

        IntegerProperty counter = new SimpleIntegerProperty(100);
        // si ahora lo cambiamos, lanzará el código de invalidation. Pero solo
        // "refrescará" cuando hagamos get, por evaluación perezosa, solo se levanta 1
        // invalidación a la vez
        /*counter.addListener(ExampleApp::invalidation);
        counter.set(101);
        counter.set(100);
        System.out.println(counter.get());
        counter.set(102);
        System.out.println(counter.get());
        counter.removeListener(ExampleApp::invalidation);*/
        // es mejor usar ChangeListener, ya que se activa cada vez que haya un cambio, a
        // contrario que el otro.
        counter.addListener(ExampleApp::changed);
        counter.set(100);
        counter.set(101);
        counter.set(102);
        counter.removeListener(ExampleApp::changed);

        IntegerProperty x = new SimpleIntegerProperty(5);
        IntegerProperty y = new SimpleIntegerProperty(10);

        //importante, eso es dinámico. Si cambia x o y, cambia el valor de sum y se registra un cambio en sum, por lo que tenemos que ahcer otro get para validarlo de nuevo.
        NumberBinding sum = x.add(y);
        System.out.println(sum.isValid()+" "+sum.getValue());
        //otra manera es
        IntegerProperty z = new SimpleIntegerProperty();
        z.bind(x.add(y));
        //si queremos desligarlo, pero mantener el ultimo valor
        //z.unbind();
        //bind es unidireccional. Z no afecta a x e y pues si lo hiciese, no podríamos recuperar x e y (hay infinitas combinaciones de x+y que darían el nuevo z)
        //solo podemos tener 1 binding unidireccional por vez. Si ponemos otro binding, se sobreescribe

        //el binding bidireccional se puede dar por ejemplo cuando hacemos que x = y, y = z. los 3 valores estarán sincronizados.
        //se hace con
        //x.bindBidirectional(y);
        los bindings permiten un montón de operaciones depende del tipo que sean. Por ejemplo podemos hacer uqe un property area haga binding 
        a radius.multiply(radius).multiply(Math.PI).
        Luego estan los objetos tipo XBinding, como NumberBinding, StringBinding u ObjectBinding, permiten crear estos bindings y poder hacer operaciones
        sobre ellos. Con lo del radio por ekemplo en vez de crear una property y hacer bind(radius...) podemos crear una NumberBinding area = radius...
        Para StringBinding podemos concaternar strings por ejemplo, y en ObjectBinding, hacer comparaciones logicas. (isEqual)
        Tambien están Boolean
        Podemos hacer algo guay y es asignar operaciones ternarias a los XBinding, por ejemplo
        IntegerProperty num = new SimpleIntegerProperty(10);
        StringBinding desc = new When(num.divide(2).multiply(2).isEqualTo(num))
                                .then("even")
                                .otherwise("odd");
 
        System.out.println(num.get() + " is " + desc.get());
 
        num.set(19);
        System.out.println(num.get() + " is " + desc.get());
        Además de las propiedades vistas, tenemos también colecciones. En concreto listas, sets y mapas.
        Para inicializar una lista observable es ObservableList<String> list = FXCollections.observableArrayList("one", "two");
        Igualmente pueden escuchar a listeners y realizarán la acción dada si se hace un cambio.
        Algo interesante es que al pasarle un listener, la función puede recibir de parametro el ListChangeListener.Change change, y esto nos 
        permite acceder a varias funciones utiles como change.wasPermutated, change.wasUpdated, etc, para actuar según el cambio realizado en la colección.
        Las funciones getFrom y getTo dentro del change vienen muy bien para determinar el rango donde se produjo el cambio.
        Otra cosa guay es el CallbackExtractor, un objeto que implementa una función call y que si se pasa como primer parametro a la lista observable se ejecutará
        cada vez que actualicemos la coleccion.
        ejemplo:
        Callback<IntegerProperty, Observable[]> extractor = (IntegerProperty p) -> {
                        // Print a message to know when it is called
                        System.out.println("The extractor is called for " + p);
                        // Wrap the parameter in an Observable[] and return it
                        return new Observable[]{p};
                };
        ObservableList<IntegerProperty> list = FXCollections.observableArrayList(extractor);
        El call es llamado por cada elemento, asi que si hago un addall(n1,n2), se llama para n1 y n2. call devuelve un array de observable, que es el parametro que le llega.
        Los sets son igual pero no permiten elementos repetidos, y los observableset tienen menos funciones para gestionar change. Principalmente wasAdded y wasRemoved, y un get
        de esos elementos. Util.
        Más de lo mismo para los mapas, pero aquí en las funciones de change podemos obtener la llave no solo el valor.

        En javaFX tenemos que crear una SimpleListProperty(ObservableList). Una vez creada si queremos modificar la lista solo debemos modificar la SimpleList, no el ObservableList.
        Podemos meter listeners como invalidated, onChanged y changed. Un ejemplo interesante:
        public static void onChanged(ListChangeListener.Change<? extends String> change) {
        while (change.next()) {
            String action = change.wasPermutated() ? "Permutated"
                    : change.wasUpdated() ? "Updated"
                            : change.wasRemoved() && change.wasAdded() ? "Replaced"
                                    : change.wasRemoved() ? "Removed" : "Added";
            System.out.print("Action taken on the list: " + action);
            System.out.print(". Removed: " + change.getRemoved());
            System.out.println(", Added: " + change.getAddedSubList());
        }
        }
        las SimpleListProperty tienen las propiedades emptyProperty y sizeProperty 
        Podemos crear ObjectBinding de elementos especificos de la lista pasando al constructor del Binding lista.sizeProperty().subtract(1). por ejemplo
        Asi cuando actualicemos la lista, también se actualizará el binding con el ultimo valor. Más util para mapas donde podemos linkear directamente
        el valor de una llave a un ObjectBinding e ir actualizandolo dinamicamente.
        Set tiene SimpleSetProperty y map SimpleMapProperty
        Un ejemplo interesante para crear un set y un stringproperty que está ligado al valor del set:
            SetProperty<String> sp1 = new SimpleSetProperty<>(FXCollections.observableSet());
    
    // Bind the size and empty properties of the SetProperty
    // to create a description of the set
    StringProperty initStr = new SimpleStringProperty("Size: " );
    StringProperty desc = new SimpleStringProperty();
    desc.bind(initStr.concat(sp1.sizeProperty())
        .concat(", Empty: ")
        .concat(sp1.emptyProperty())
        .concat(", Set: " )
        .concat(sp1.asString())
    );
    Para los diagramas podrían ser interesantes o las clases Builder o lo que viene aqui https://stackoverflow.com/questions/30679025/graph-visualisation-like-yfiles-in-javafx
    BUSCAR GRIDPANE de javafx